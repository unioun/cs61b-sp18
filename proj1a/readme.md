# 小结
* 本次写ArrayDeque花了太长的时间，本以为很简单的东西却为以我的考虑不充分而花费的如此大的代价。
  * 一方面，我最开始使用的是两条数组用来维护数据，结果在remove 的时候发生了问题，我是一条数组前来装`removeFirst()`，另一条数组用来装`removeLast()`，但是，当第一条数组全部删除后，再`removeFirst()`时，就要处理另一条数组了，这下逻辑太乱了。
  * 当第一种方案不行时，我立刻采用第二种方案，把数组抽像成环状具体方法如下:
    * 创建一个空数组，以数组中间为起点，定义两个指针，一个head，一个tail。分别用来代表从外界来看这个Deque 的头和尾。
    * 每次`addFirst()`的时候，我都让`head--`，我允许head能为负数，问题正是出于此。tail能在于数组的长度，当head为负数的时候，我让它从数组的另一头开台填。虽然节省了不少空间，但是映射抽像的索引和实际的索引时实在是太复杂了。尤其是在数组排满了后，给数组`resize()`的时候。但是由head为负数的部分和tail大于数组长度的部分填写的顺序是反的，所以，这一部分要一个个遍历才能复制到新数组而不能采用`System.arraycopy()`的方法。这些问题所产生的Bug着实让人痛苦。
    * 最终，我不让head和tail有那样的超能力了，写起来轻松多了，但`resize()`,仍然是这个类的核心之一。其中的逻辑仍是最复杂的。
* 老师给出的sentinel方法确实好用，在写LinkedListDeque时还是不得不采用它，不然在Deque为空时，填加第一个item时一个会多一个判断语句，这样的代码很丑，因为每次这里都要多判断一次。
* 从别的地方copy过来的代码最容易出bug
* 写测试很重要。
